location /citalis.lls {

	add_header Allow "GET, POST, HEAD" always;
	if ( $request_method !~ ^(GET|POST|HEAD)$ ) { return 405; }

	content_by_lua '

    local sock, activeSock, ok, err, req, bytes, headers, part, line, readline, postIn, args = 
    	ngx.socket.tcp(), "", "", "", "", "", "", "", "", "", "", ""
    
    sock:settimeout(10000) -- 10 seconds timeout
   	
   	if ngx.var.host == "192.168.1.15" then -- dev --
 			ok, err = sock:connect("127.0.0.1", "9577")
	  	if not ok
	  	then ngx.say("failed to connect: ", err); return
			else activeSock = "9577" end
   	else -- prod with auto-handled round-robin loop --
	    ok, err = sock:connect("127.0.0.1", "9578")
	    if not ok then
				ok, err = sock:connect("127.0.0.1", "9579")
		  	if not ok
		  	then ngx.say("failed to connect: ", err); return
				else activeSock = "9579" end
	    else activeSock = "9578" end
		end
    
    if ngx.var.request_method == "POST" then -- POST data --
     	ngx.req.read_body(); args = ngx.req.get_post_args(6)            
 			for key, val in pairs(args) do postIn = postIn .. "&" .. key .. "=" .. val end
 	  	req = "method=_POST" .. ngx.escape_uri(postIn) .. "\\r\\n"
    else req = "method=_GET\\r\\n" end 				-- GET data --
    bytes, err = sock:send(req)
    if not bytes
    then ngx.say("failed to send request: ", err); return end
    	
    readline = sock:receiveuntil("\\r\\n", { inclusive = false })
    line, err, part = readline()
    if line -- "\\r\\n" received
		then ngx.say(line)
    elseif part -- "\\r\\n" not received
		then ngx.print(part) -- ngx.say(part)
    else ngx.say("failed to read a line: ", err, " [", part, "]") end
		
    sock:close()

	';
    
}
